struct CooElement {
       row : i32,
       col : i32,
       value : f64
}

struct CooVectorElement {
    pos : i32,
    value : f64
}

fn @(?a & ?b & ?s) unroll_step(a : i32, @b : i32, @s : i32, f : fn(i32) -> ()) -> () {
    if a < b { 
        @@f(a); 
        unroll_step(a + s, b, s, f) 
    }
}
fn @unroll(a : i32, b : i32, f : fn(i32) -> ()) -> () { 
    unroll_step(a, b, 1, f) 
}

extern "C" {
    fn println(i32) -> ();
}

// Multiplies sparse matrix by sparse vector
// Both in COO format
extern
fn @mult_matrix_vector(
        coo: &[CooElement],
        matrix_rows: i32,
        matrix_cols: i32,
        nonzero_count: i32,
        vector: &[CooVectorElement],
        vector_nonzero_count : i32,
        buffer: &mut [CooVectorElement],
        result: &mut [CooVectorElement],
        result_size: &mut i32) -> () {

    let mut current_buffer_pos : i32 = 0; 
    for i in unroll(0, nonzero_count) {
        buffer(current_buffer_pos).pos = coo(i).row;

        for j in unroll(0, vector_nonzero_count) {
            if vector(j).pos == coo(i).row {
                let new_value : f64 = vector(j).value * coo(i).value;
                buffer(current_buffer_pos).value = new_value;
                current_buffer_pos += 1
            }
        }
    }

    let mut current_result_pos : i32 = 0;
    for i in unroll(0, current_buffer_pos) {
        for j in unroll(0, current_result_pos + 1) {
            if j == current_result_pos {
                result(current_result_pos) = buffer(i);
                current_result_pos += 1;
                break()
            } else if result(j).pos == buffer(i).pos {
                result(j).value += buffer(i).value
            }
        }
    }

    *result_size = current_result_pos 
}
